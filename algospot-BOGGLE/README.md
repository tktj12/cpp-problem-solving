# Problem
* https://algospot.com/judge/problem/read/BOGGLE
* 난이도 : 하

# Solution
 
* 방법 1 : 재귀호출 (시간초과)
1. 게임판의 한 곳을 문자열의 시작으로 기준잡는다. 아직 해당 문자열이 발견되지 않았다면 det() 함수를 호출한다.
2. 다음으로 갈 수 있는 곳의 문자들을 각각 검사한다.
3. 일치하는 문자마다 자기자신(det())을 다시 호출하여 2번 과정으로 돌아간다.
4. 모두 일치하면 isFound를 true로 설정하고 함수를 종료한다.
5. 게임판의 왼쪽 위부터 오른쪽 아래까지 과정1~4를 반복한다.

N이 입력 문자열의 수이고 M이 문자열의 길이라면,
시간복잡도는 최악의 경우 
`O(25*8<sup>M-1</sup>N) = O(8<sup>M</sup>N)`
일 것 같다.

이 문제는 N, M이 최대 10이지만, 케이스의 수까지 고려하면 너무 많은 시간이 소요된다.
<br><br>

* 방법 2 :

# Learning