# Problem
* https://algospot.com/judge/problem/read/HANOI4
* 하노이의 탑 게임에서 기둥이 3개가 아닌 4개이고 게임의 상태가 주어질 때 게임을 풀기 위한 최소한의 움직임 구하기
* 난이도 : 상

# Solution
* 기둥에 큰 원반부터 놓을 수 있고 기둥이 총 4개이므로 가능한 상태의 개수는 $4^n$이다. 
(크기가 $n$인 원반을 놓는 경우 4가지 x $n$-1인 원반 놓는 경우 4가지 x ... x 1인 원반 놓는 경우 4가지)
* $n$이 최대 12이므로 가능한 상태는 최대 1600만 정도 된다. 따라서 상태공간의 크기는 최대 1600만 정도이다.
* 하노이의 네 탑의 한 상태에서 원반을 하나만 옮겨서 만들 수 있는 다른 상태는 최대 6가지이다.   
네 기둥에 전부 원반이 꽂혀있을 때 꼭대기에 있는 원반 중 가장 작은 원반을 다른 기둥으로 옮기는 경우는 3가지가 있다. 
두 번째로 작은 원반을 옮기는 경우는 2가지가 있고, 세 번째로 작은 원반을 옮기는 경우는 1가지가 있다.   
따라서 n번 움직였을 때 $O(6^n)$ 만큼의 상태를 보는 셈이고, 최악의 경우 총 1600만 x 6 = 6400만의 연산을 하는 셈이다. 
시간 제한은 5초이고 테스트케이스가 50개나 되기 때문에 이렇게 해서는 시간 안에 문제를 풀 수 없다. 
하노이의 탑은 반대로 문제를 풀어도 똑같기 때문에 양방향 탐색으로 문제를 해결할 수 있다.

### 방법 1 : 양방향 BFS (종만북 풀이)
* 풀이
  * 먼저 어느 기둥에 어떤 원반이 꽂혀 있는지에 대한 정보를 표현해야 한다. 
이 문제의 경우 기둥의 개수는 4개이다. 따라서 기둥의 번호를 0~3까지 매길 수 있고, 
이건 이진수로 2비트로 표현할 수 있는 값이다. 
원반의 최대 개수는 12개이다. 12개의 원반 각각이 어느 기둥에 있는지를 2비트로 표현해도 24비트 밖에 사용하지 않는다.
또한 원반이 꽂힌 순서는 어차피 크기에 따라 정해지기 때문에 그냥 원반이 어느 기둥에 있는지로 알 수 있는 정보이다. 
따라서 게임의 현재 상태를 32비트 int 타입 변수로 표현할 수 있다.
  * 단방향 BFS로는 너무 많은 상태를 보게 된다. 하지만 이 문제는 역방향으로도 풀 수 있으므로 
양방향으로 풀어서 시간과 공간을 절약할 수 있다.

* 시간 복잡도 :
  * $O(P^{n/2})$ , $P$ : 기둥의 개수, $n$ : 원반의 개수
<br></br>
