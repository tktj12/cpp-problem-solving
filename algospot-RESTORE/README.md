# Problem
* https://algospot.com/judge/problem/read/RESTORE
* 부분문자열들이 모두 포함된 문자열 중 가장 짧은 것 찾기
* 난이도 : 상

# Solution
### 분석
* 불필요한 부분을 얼마나 줄일 수 있는지가 중요하다.
* bc, abcd 처럼 한 부분 문자열 전부가 다른 부분 문자열의 부분과 겹친다면 그 부분 문자열은 필요없다. 즉 bc는 필요없다.
* 때문에 abc, bcd 처럼 부분 문자열의 왼쪽, 오른쪽이 일치하는 경우만 abcd로 합칠 수 있다. abc, abd 같은 형식은 불가능하다.
* 또한 abc, cd, def 같은 경우 cd가 필요 없어진다.
* AAB, BAA, AABAA 의 경우 처음에 BAAB를 만들면 최선의 경우인 AABAA를 찾을 수 없을 것이다.
* AAB, BAA, BAAAB 의 경우 처음에 BAAB를 만들면 최선의 경우인 BAAAB를 찾을 수 없을 것이다.

### 방법 1 : 완전 탐색
* 풀이
  * 부분 문제를 현재까지 만든 문자열과 사용하지 않은 부분 문자열들을 사용하여 만들 수 있는 가장 짧은 문자열을 구하는 것으로 설정
  * 다음 부분 문자열이 이미 사용됐거나 현재까지 만든 문자열의 부분 문자열이면 해당 부분 문자열은 붙일 필요가 없다.
붙이는 경우 오른쪽에 가장 짧게 붙이는 경우와 왼쪽에 가장 짧게 붙이는 경우를 모두 탐색하여 가장 짧은 문자열을 반환

* 시간 복잡도 :
  * 빈 문자열 부터 시작해서 부분 문자열을 가능한 모든 순서대로 탐색하며 이어붙임. 즉 $N!$개의 경우를 모두 탐색
  * $O(N!)$
<br></br>

### 방법 2 : 동적 계획법
* 풀이
  * 부분 문자열들 끼리는 서로가 서로의 부분 문자열인 것이 없게 만들자. 
이렇게 하면 문자열의 왼쪽부터 부분문자열을 채워 가며 겹치는 부분만 없애주면 된다.
  * 이러면 '앞쪽에 선택한 부분 문자열'과 '지금까지 선택한 부분 문자열들'이 같으면 부분 문제의 정답도 같게 된다.
  * 따라서 (앞쪽에 선택한 문자열의 인덱스, 선택한 문자열들의 비트마스크)로 동적 계획법을 사용할 수 있다.

* 시간 복잡도 :
  * 부분 문제의 개수 $O(n2^n)$과 부분 문제마다 $O(n^2)$ 시간이 걸린다.
  * $O(n^3 2^n)$

* 겹치는 부분 길이(coincide)를 미리 계산해놓는 방법도 있다.
<br></br>

